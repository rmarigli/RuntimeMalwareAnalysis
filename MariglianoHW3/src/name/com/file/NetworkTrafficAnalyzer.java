package name.com.file;
import java.io.*;
import java.util.HashMap;
import java.util.HashSet;
import java.util.Iterator;
import java.util.Map;
import java.util.Set;
import java.util.ArrayList;

class Event{
	public String type;
}

class NetworkEvents extends Event{
	public String src_ip;
	public String dst_ip;
	public String proto;
	public String flags;
	public int entry_index;
}

class MJReadEvent extends Event{
	public String address;
	public String pid;
	public String imageFile;
}

class MJWriteEvent extends Event {
	public String address;
	public String pid;
	public String imageFile;
}

class MJCreateEvent extends Event {
	public String disposition;
	public String pid;
	public String imageFile;
}

class VMWriteEvent extends Event {
	public String targetPid;
	public String requestorPid;
}

class VMTerminateEvent extends Event {
	public String targetPid;
	public String requestorPid;
}

class VMAllEvent extends Event {
	public String targetPid;
	public String requestorPid;
}

class LoadImageEvent extends Event {
	public String imageFile;
	public String targetPid;
	public String injectorPid;
	public String baseImageAddress;
}

class ProcessCreateEvent extends Event {
	public String pid;
	public String ppid;
	public String imageFile;
	public String address;
}

class RegCreateKeyEvent extends Event {
	public String pid;
	public String key;
	
}

class RegCreateKeyExEvent extends Event {
	public String pid;
	public String key;
}

class RegSetValueKeyEvent extends Event {
	public String pid;
	public String key;
	public String value;
}

class RegDeleteKeyEvent extends Event {
	public String pid;
	public String key;
}

class RegDeleteValueKeyEvent extends Event {
	public String pid;
	public String key;
	public String value;
}

class RegRenameKeyEvent extends Event {
	public String pid;
	public String oldKey;
	public String newKey;
}

class RegReplaceKeyEvent extends Event {
	public String pid;
	public String regFile;
}

class Node {
	public String pid;
	public String imageFile;
	
	public String createNodeString() {
		return this.pid + "," + this.imageFile;
	}
}

class Process{
	public String pid;
	public String imageFile;
	public String name;
	int ip_conns;
	public ArrayList<NetworkEvents> pe;
	double susp;
	int susp_index; //whenever 2 syn events occurs between 10 entries, increase it by one
	
	public Process() {
	}
	
	public Process(String _name){
		ip_conns=0;
		name= _name;
		pe= new ArrayList<NetworkEvents>();
		susp=0.0;
		susp_index= 1;
	}
	
	//4 is process name,5 is src, 6 is dst, 7 is protocol, 8 is flags
	public void addEvent(String line,int index)
	{
		String elems[]= line.split("\\s+");
		NetworkEvents p; 
		if(elems[7].equals("TCP"))	//now only care TCP events
		{
			//System.out.println("TCP Event Found!");
			p= new NetworkEvents();
			p.proto="TCP";
		}
		else 
			return;
		p.src_ip= elems[5];
		p.dst_ip= elems[6];
		p.flags= elems[8];
		p.entry_index= index;
		pe.add(p);
		ip_conns+=1;
	}
}

public class NetworkTrafficAnalyzer { 
	
	private static double susp_base= 0.02;
	private static int sups_interval= 10; //least # of entries between for low frequency IP evnets
	private static ArrayList<Event> events= new ArrayList<Event>();
	private static FileOutputStream fop;
	
	public static void main (String args[])throws Exception{
		HashMap<String, Process> hmap = new HashMap<String, Process>(); //store processes
		HashSet<String> hset= new HashSet<String>();
		
		//File fin= new File("C:\\Users\\venceWEN\\Desktop\\TCPEvents.txt");
		File fin= new File("log.txt");
		
		File file = new File("mit.csv");
		fop = new FileOutputStream(file);
		readFile1(fin,hmap,hset);
		analyzeP1(hmap);
		analyzeP2(hmap);
		analyzeF1();
		analyzeF2(hmap);
		analyzeF3(hmap);
		analyzeNetworkEvents(hmap,hset);
		
		fop.flush();
		fop.close();
		
		displaySusp(hmap);
		//dispDNS(hset);
	}
	
	private static String parseColonString(String input) {
		int colonIndex = input.indexOf(":");
		String output = input.substring(colonIndex+1);
		return output;
	}
	
	private static void displaySusp(HashMap<String, Process> hmap)
	{
		Set set = hmap.entrySet();
		Iterator iterator = set.iterator();
		System.out.println("===========final report========");
		while(iterator.hasNext()) {
			Map.Entry mentry = (Map.Entry)iterator.next();
			System.out.print("process is: "+ mentry.getKey()+" ,");
			
			Process p= (Process)(mentry.getValue());
			if(p.susp<1)
				System.out.println("susp level: "+p.susp);
			else
				System.out.println("susp level: "+1);
		}
	}
	
	private static void analyzeF1() throws IOException {
		for(int i = 0; i < events.size(); i++) {
			if (events.get(i).type.equals("IRP_MJ_READ") && events.get(i+1).type.equals("IRP_MJ_WRITE")) {
				String readAddress = ((MJReadEvent)events.get(i)).address;
				String writeAddress = ((MJWriteEvent)events.get(i+1)).address;
				if (readAddress.equals(writeAddress)) {
					Node readNode = new Node();
					readNode.pid = ((MJReadEvent)events.get(i)).pid;
					readNode.imageFile = ((MJReadEvent)events.get(i)).imageFile;
					
					Node writeNode = new Node();
					writeNode.pid = ((MJWriteEvent)events.get(i+1)).pid;
					writeNode.imageFile = ((MJWriteEvent)events.get(i+1)).imageFile;
					String output = readNode.createNodeString() + "; f1; " + writeNode.createNodeString() + "\r\n";
					fop.write(output.getBytes());
				}
			}
		}
	}
	
	private static void analyzeF2(HashMap<String, Process> hmap) throws IOException {
		for(int i = 0; i < events.size(); i++) {
			if (events.get(i).type.equals("IRP_MJ_CREATE")) {
				
					Node createNode = new Node();
					createNode.pid = null;
					createNode.imageFile = ((MJCreateEvent)events.get(i)).imageFile;
					
					String creatorPid = ((MJCreateEvent)events.get(i)).pid;
					String imageFile = null;
					if (hmap.get(creatorPid) != null)
						imageFile = hmap.get(creatorPid).imageFile;
						
					String output =   creatorPid + ", " + imageFile + "; f2; " + createNode.createNodeString() + "\r\n";
					fop.write(output.getBytes());
			}
		}
	}
	
	private static void analyzeF3(HashMap<String, Process> hmap) throws IOException {
		for(int i = 0; i < events.size(); i++) {
			if (events.get(i).type.equals("IRP_MJ_WRITE")) {
				
					String childPid = null;
					String childImageFile = ((MJWriteEvent)events.get(i)).imageFile;
					
					String creatorPid = ((MJWriteEvent)events.get(i)).pid;
					String creatorImageFile = null;
					if (hmap.get(creatorPid) != null)
						creatorImageFile = hmap.get(creatorPid).imageFile;
					
					
					String output =   creatorPid + ", " + creatorImageFile + "; f3; " + childPid + ", " + childImageFile + "\n";
					fop.write(output.getBytes());
			}
		}
	}
	
	private static void analyzeP1(HashMap<String, Process> hmap) throws IOException {
		for(int i = 0; i < events.size(); i++) {
			if (events.get(i).type.equals("PROCESS_VM_WRITE")) {
				VMWriteEvent vmWriteEvent = ((VMWriteEvent)events.get(i));
				
				String requestorPid = vmWriteEvent.requestorPid;
				String targetPid = vmWriteEvent.targetPid;
				String requestorImageFile = null;
				String targetImageFile = null;
				
				if (hmap.get(requestorPid) != null)
					requestorImageFile = hmap.get(requestorPid).imageFile;
				if (hmap.get(targetPid) != null)
					targetImageFile = hmap.get(targetPid).imageFile;
				
				String result = requestorPid + ", " + requestorImageFile + "; p1; " + targetPid + ", " + targetImageFile + "\n";
				fop.write(result.getBytes());
				
			}
			else if (events.get(i).type.equals("PROCESS_TERMINATE")){
				VMTerminateEvent vmTerminateEvent = ((VMTerminateEvent)events.get(i));
				
				String requestorPid = vmTerminateEvent.requestorPid;
				String targetPid = vmTerminateEvent.targetPid;
				String requestorImageFile = null;
				String targetImageFile = null;
				
				if (hmap.get(requestorPid) != null)
					requestorImageFile = hmap.get(requestorPid).imageFile;
				if (hmap.get(targetPid) != null)
					targetImageFile = hmap.get(targetPid).imageFile;
				
				String result = requestorPid + ", " + requestorImageFile + "; p1; " + targetPid + ", " + targetImageFile + "\n";
				fop.write(result.getBytes());
			}
			else if (events.get(i).type.equals("PROCESS_ALL_ACCESS")) {
				VMAllEvent vmAllEvent = ((VMAllEvent)events.get(i));
				
				String requestorPid = vmAllEvent.requestorPid;
				String targetPid = vmAllEvent.targetPid;
				String requestorImageFile = null;
				String targetImageFile = null;
				
				if (hmap.get(requestorPid) != null)
					requestorImageFile = hmap.get(requestorPid).imageFile;
				if (hmap.get(targetPid) != null)
					targetImageFile = hmap.get(targetPid).imageFile;
				
				String result = requestorPid + ", " + requestorImageFile + "; p1; " + targetPid + ", " + targetImageFile + "\n";
				fop.write(result.getBytes());
			}
		}
	}
	
	private static void analyzeP2(HashMap<String, Process> hmap) throws IOException {
		for(int i = 0; i < events.size(); i++) {
			if (events.get(i).type.equals("TrueProcess-Created")) {
				ProcessCreateEvent processCreateEvent = ((ProcessCreateEvent)events.get(i));
				
				String creatorPid = processCreateEvent.ppid;
				String childPid = processCreateEvent.pid;
				String creatorImageFile = null;
				String childImageFile = null;
				
				if (hmap.get(creatorPid) != null)
					creatorImageFile = hmap.get(creatorPid).imageFile;
				
				if (hmap.get(childPid) != null)
					childImageFile = hmap.get(childPid).imageFile;
				
				String output =   creatorPid + ", " + creatorImageFile + "; p2; " + childPid + ", " + childImageFile + "\n";
				fop.write(output.getBytes());
			}
		}
	}
	
	private static void analyzeNetworkEvents(HashMap<String, Process> hmap,HashSet<String> hset)
	{
		Set set = hmap.entrySet();
		Iterator iterator = set.iterator();
		while(iterator.hasNext()) {
			Map.Entry mentry = (Map.Entry)iterator.next();
			System.out.print("process is: "+ mentry.getKey()+", ");
			Process p= (Process)(mentry.getValue());
			System.out.println("events: "+p.ip_conns);
			
			int last_entry_index=0;
			int interval=0;
			for(int i=0; i<p.ip_conns;i++)
			{
				NetworkEvents pe= p.pe.get(i);
				if(pe.proto.equals("TCP") && pe.flags.equals("TCP:Flags=......S.,")) //SYN events
				{
					if(interval!=0) //update interval and last entry index
					{
						interval= p.pe.get(i).entry_index - last_entry_index;
						last_entry_index= p.pe.get(i).entry_index;
					}
					else
					{
						interval= 1000;
						last_entry_index= p.pe.get(i).entry_index;
					}
					
					if(interval<sups_interval)
					{
						//System.out.println("increase susp index!,interval:"+interval);
						p.susp_index+=1;
					}
					else
					{
						//System.out.println("reset susp index!interval:"+interval);
						p.susp_index=1;
					}
					
					//System.out.println("TCP Syn Found!");
					//System.out.println(pe.proto+" "+pe.flags+" "+pe.src_ip+" "+pe.dst_ip);
					int k;
					for( k=i;k<p.ip_conns;k++)
					{
						NetworkEvents pe2= p.pe.get(k);
						if(pe2.src_ip.equals(pe.dst_ip) && pe2.flags.equals("TCP:Flags=...A..S.,"))
						{
							System.out.println("TCP Connection Successful!");
							p.susp+= susp_base * p.susp_index;
							break;
						}
					}
					if(k==p.ip_conns)
					{
						System.out.println("TCP Connection fail!");
						if(hset.contains(pe.dst_ip))
						{
							System.out.println("there is dns history!");
							p.susp+= susp_base*4* p.susp_index;
						}
						else
						{
							System.out.println("no dns history!");
							p.susp+= susp_base*3* p.susp_index;
						}
					}
				}
			}
		}

	}
	
	private static void dispDNS(HashSet<String> hset)
	{
		Iterator<String> it = hset.iterator();
	     while(it.hasNext()){
	        System.out.println(it.next());
	     }
	}
	
	private static void readFile1(File fin,HashMap<String, Process> hmap,HashSet<String> hset) throws IOException {
		FileInputStream fis = new FileInputStream(fin);
		//Construct BufferedReader from InputStreamReader
		BufferedReader br = new BufferedReader(new InputStreamReader(fis));
		
		String line = null;
		int en_index=0;
		while ((line = br.readLine()) != null) {
			//System.out.println(line);
			if(line.contains("@@@")) {
				String debugOutput = line.split("@@@ ")[1];
				String info_old[] = debugOutput.split(","); // TODO: change name of variable
				String info[] = new String[info_old.length];
				
				for (int i = 1; i < info_old.length; i++) {
					info[i] = parseColonString(info_old[i]);
				}
				info[0] = info_old[0];
				String event = info[0].replaceAll("\\s+", "");
				
				switch(event) {
					case "IRP_MJ_CREATE":
						MJCreateEvent createEvent = new MJCreateEvent();
						createEvent.type = event;
						createEvent.pid = info[1].replaceAll("\\s+", "");
						createEvent.imageFile = info[2].replaceAll("\\s+", "");
						createEvent.disposition = info[3].replaceAll("\\s+", "");
						events.add(createEvent);
						break;
					case "IRP_MJ_READ":
						MJReadEvent readEvent = new MJReadEvent();
						readEvent.type = event;
						readEvent.pid = info[1].replaceAll("\\s+", "");
						readEvent.address = info[2].replaceAll("\\s+", "");
						readEvent.imageFile = info[3].replaceAll("\\s+", "");
						events.add(readEvent);
						break;
					case "IRP_MJ_WRITE":
						MJWriteEvent writeEvent = new MJWriteEvent();
						writeEvent.type = event;
						writeEvent.pid = info[1].replaceAll("\\s+", "");
						writeEvent.address = info[2].replaceAll("\\s+", "");
						writeEvent.imageFile = info[3].replaceAll("\\s+", "");
						events.add(writeEvent);
						break;
					case "Proces-memory-write-access-attempt":
						VMWriteEvent vmWriteEvent = new VMWriteEvent();
						vmWriteEvent.targetPid = info[1].replaceAll("\\s+", "");
						vmWriteEvent.requestorPid = info[2].replaceAll("\\s+", "");
						vmWriteEvent.type = info[3].replaceAll("\\s+", "");
						events.add(vmWriteEvent);
						break;
					case "Proces-terminate-attempt":
						VMTerminateEvent vmTerminateEvent = new VMTerminateEvent();
						vmTerminateEvent.targetPid = info[1].replaceAll("\\s+", "");
						vmTerminateEvent.requestorPid = info[2].replaceAll("\\s+", "");
						vmTerminateEvent.type = info[3].replaceAll("\\s+", "");
						events.add(vmTerminateEvent);
						break;
					case "TrueProcess-Created":
						ProcessCreateEvent processCreateEvent = new ProcessCreateEvent();
						String pid = info[1].replaceAll("\\s+", "");
						String imageFile = info[3].replaceAll("\\s+", "");
						
						processCreateEvent.pid = pid;
						processCreateEvent.ppid = info[2].replaceAll("\\s+", "");
						processCreateEvent.imageFile = imageFile;
						processCreateEvent.address = info[4].replaceAll("\\s+", "");
						processCreateEvent.type = event;
						
						Process process = new Process();
						process.pid = pid;
						process.imageFile = imageFile;
						
						hmap.put(pid, process);
						events.add(processCreateEvent);
						break;
					case "Proces-memory-write-delete-access-attempt":
						VMAllEvent vmAllEvent = new VMAllEvent();
						vmAllEvent.targetPid = info[1].replaceAll("\\s+", "");
						vmAllEvent.requestorPid = info[2].replaceAll("\\s+", "");
						vmAllEvent.type = info[3].replaceAll("\\s+", "");
						events.add(vmAllEvent);
						break;
					case "RegNtPreCreateKeyEx":
						RegCreateKeyExEvent createKeyExEvent = new RegCreateKeyExEvent();
						createKeyExEvent.type = event;
						createKeyExEvent.key = info[1].replaceAll("\\s+", "");
						createKeyExEvent.pid = info[2].replaceAll("\\s+", "");
						events.add(createKeyExEvent);
						break;
					case "RegCreateKeyEvent":
						RegCreateKeyEvent createKeyEvent = new RegCreateKeyEvent();
						createKeyEvent.type = event;
						createKeyEvent.key = info[1].replaceAll("\\s+", "");
						createKeyEvent.pid = info[2].replaceAll("\\s+", "");
						events.add(createKeyEvent);
						break;
					case "RegNtPreSetValueKey":
						RegSetValueKeyEvent regSetValueKeyEvent = new RegSetValueKeyEvent();
						regSetValueKeyEvent.type = event;
						regSetValueKeyEvent.key = info[1].replaceAll("\\s+", "");
						regSetValueKeyEvent.pid = info[2].replaceAll("\\s+", "");
						regSetValueKeyEvent.value = info[3].replaceAll("\\s+", "");
						events.add(regSetValueKeyEvent);
						break;
					case "RegNtDeleteKey":
						RegDeleteKeyEvent regDeleteKeyEvent = new RegDeleteKeyEvent();
						regDeleteKeyEvent.type = event;
						regDeleteKeyEvent.key = info[1].replaceAll("\\s+", "");
						regDeleteKeyEvent.pid = info[2].replaceAll("\\s+", "");
						events.add(regDeleteKeyEvent);
						break;
					case "RegNtDeleteValueKey":
						RegDeleteValueKeyEvent regDeleteValueKeyEvent = new RegDeleteValueKeyEvent();
						regDeleteValueKeyEvent.type = event;
						regDeleteValueKeyEvent.key = info[1].replaceAll("\\s+", "");
						regDeleteValueKeyEvent.value = info[2].replaceAll("\\s+", "");
						regDeleteValueKeyEvent.pid = info[3].replaceAll("\\s+", "");
						events.add(regDeleteValueKeyEvent);
						break;
					case "RegNtPreRenameKey":
						RegRenameKeyEvent regRenameKeyEvent = new RegRenameKeyEvent();
						regRenameKeyEvent.type = event;
						regRenameKeyEvent.oldKey = info[1].replaceAll("\\s+", "");
						regRenameKeyEvent.newKey = info[2].replaceAll("\\s+", "");
						regRenameKeyEvent.pid = info[3].replaceAll("\\s+", "");
						events.add(regRenameKeyEvent);
						break;
					case "RegNtPreReplaceKey":
						RegReplaceKeyEvent regReplaceKeyEvent = new RegReplaceKeyEvent();
						regReplaceKeyEvent.type = event;
						regReplaceKeyEvent.regFile = info[1].replaceAll("\\s+", "");
						regReplaceKeyEvent.pid = info[2].replaceAll("\\s+", "");
						events.add(regReplaceKeyEvent);
						break;
					default:
						System.out.println("Incorrect event type");
						break;
				}
			}
			else {
				String elems[]= line.split("\\s+");
				//4 is process name,5 is src, 6 is dst, 7 is protocol, 8 is flags
				if(elems[7].equals("TCP"))  //only track process with TCP events
				{
					if(hmap.containsKey(elems[4]))
						hmap.get(elems[4]).addEvent(line,en_index);
					else
					{
						hmap.put(elems[4], new Process(elems[4]));
						hmap.get(elems[4]).addEvent(line,en_index);
					}
				}
				else if( elems[6].equals("DNS") && elems[15].equals("Success,"))
				{
					int i=16;
					while(!elems[i].contains("DNS"))
					{
						hset.add(elems[i]);
						i+=1;
					}
				}
				en_index++;
			}
		}
		br.close();
	}
}
