package javaApp;
import java.io.*;
import java.util.HashMap;
import java.util.HashSet;
import java.util.Iterator;
import java.util.Map;
import java.util.Set;
import java.util.ArrayList;

class Event{
	public String type;
}

class NetworkEvents extends Event{
	public String src_ip;
	public String dst_ip;
	public String proto;
	public String flags;
	public int entry_index;
}

class MJReadEvent extends Event{
	
}


class Process{
	public String name;
	int ip_conns;
	public ArrayList<ProcessEvents> pe;
	double susp;
	int susp_index; //whenever 2 syn events occurs between 10 entries, increase it by one
	
	public Process(String _name){
		ip_conns=0;
		name= _name;
		pe= new ArrayList<ProcessEvents>();
		susp=0.0;
		susp_index= 1;
	}
	
	//4 is process name,5 is src, 6 is dst, 7 is protocol, 8 is flags
	public void addEvent(String line,int index)
	{
		String elems[]= line.split("\\s+");
		ProcessEvents p; 
		if(elems[7].equals("TCP"))	//now only care TCP events
		{
			//System.out.println("TCP Event Found!");
			p= new ProcessEvents();
			p.proto="TCP";
		}
		else 
			return;
		p.src_ip= elems[5];
		p.dst_ip= elems[6];
		p.flags= elems[8];
		p.entry_index= index;
		pe.add(p);
		ip_conns+=1;
	}
}


public class NetworkTrafficAnalyzer { 
	
	private static double susp_base= 0.02;
	private static int sups_interval= 10; //least # of entries between for low frequency IP evnets
	
	public static void main (String args[])throws Exception{
		HashMap<String, Process> hmap = new HashMap<String, Process>(); //store processes
		HashSet<String> hset= new HashSet<String>();
		
		ArrayList<Event> events= new ArrayList<Event>();
		
		//File fin= new File("C:\\Users\\venceWEN\\Desktop\\TCPEvents.txt");
		File fin= new File("C:\\Users\\venceWEN\\Desktop\\allEvents.txt");
		readFile1(fin,hmap,hset);
		analyzeEvents(hmap,hset);
		displaySusp(hmap);
		//dispDNS(hset);
	}
	
	private static void displaySusp(HashMap<String, Process> hmap)
	{
		Set set = hmap.entrySet();
		Iterator iterator = set.iterator();
		System.out.println("===========final report========");
		while(iterator.hasNext()) {
			Map.Entry mentry = (Map.Entry)iterator.next();
			System.out.print("process is: "+ mentry.getKey()+" ,");
			
			Process p= (Process)(mentry.getValue());
			if(p.susp<1)
				System.out.println("susp level: "+p.susp);
			else
				System.out.println("susp level: "+1);
		}
	}
	
	private static void analyzeEvents(HashMap<String, Process> hmap,HashSet<String> hset)
	{
		Set set = hmap.entrySet();
		Iterator iterator = set.iterator();
		while(iterator.hasNext()) {
			Map.Entry mentry = (Map.Entry)iterator.next();
			System.out.print("process is: "+ mentry.getKey()+", ");
			Process p= (Process)(mentry.getValue());
			System.out.println("events: "+p.ip_conns);
			
			int last_entry_index=0;
			int interval=0;
			for(int i=0; i<p.ip_conns;i++)
			{
				ProcessEvents pe= p.pe.get(i);
				if(pe.proto.equals("TCP") && pe.flags.equals("TCP:Flags=......S.,")) //SYN events
				{
					if(interval!=0) //update interval and last entry index
					{
						interval= p.pe.get(i).entry_index - last_entry_index;
						last_entry_index= p.pe.get(i).entry_index;
					}
					else
					{
						interval= 1000;
						last_entry_index= p.pe.get(i).entry_index;
					}
					
					if(interval<sups_interval)
					{
						//System.out.println("increase susp index!,interval:"+interval);
						p.susp_index+=1;
					}
					else
					{
						//System.out.println("reset susp index!interval:"+interval);
						p.susp_index=1;
					}
					
					//System.out.println("TCP Syn Found!");
					//System.out.println(pe.proto+" "+pe.flags+" "+pe.src_ip+" "+pe.dst_ip);
					int k;
					for( k=i;k<p.ip_conns;k++)
					{
						ProcessEvents pe2= p.pe.get(k);
						if(pe2.src_ip.equals(pe.dst_ip) && pe2.flags.equals("TCP:Flags=...A..S.,"))
						{
							System.out.println("TCP Connection Successful!");
							p.susp+= susp_base * p.susp_index;
							break;
						}
					}
					if(k==p.ip_conns)
					{
						System.out.println("TCP Connection fail!");
						if(hset.contains(pe.dst_ip))
						{
							System.out.println("there is dns history!");
							p.susp+= susp_base*4* p.susp_index;
						}
						else
						{
							System.out.println("no dns history!");
							p.susp+= susp_base*3* p.susp_index;
						}
					}
				}
			}
		}

	}
	
	private static void dispDNS(HashSet<String> hset)
	{
		Iterator<String> it = hset.iterator();
	     while(it.hasNext()){
	        System.out.println(it.next());
	     }
	}
	
	private static void readFile1(File fin,HashMap<String, Process> hmap,HashSet<String> hset) throws IOException {
		FileInputStream fis = new FileInputStream(fin);
		//Construct BufferedReader from InputStreamReader
		BufferedReader br = new BufferedReader(new InputStreamReader(fis));
		
		String line = null;
		int en_index=0;
		while ((line = br.readLine()) != null) {
			//System.out.println(line);
			String elems[]= line.split("\\s+");
			//4 is process name,5 is src, 6 is dst, 7 is protocol, 8 is flags
			if(elems[7].equals("TCP"))  //only track process with TCP events
			{
				if(hmap.containsKey(elems[4]))
					hmap.get(elems[4]).addEvent(line,en_index);
				else
				{
					hmap.put(elems[4], new Process(elems[4]));
					hmap.get(elems[4]).addEvent(line,en_index);
				}
			}
			else if( elems[6].equals("DNS") && elems[15].equals("Success,"))
			{
				int i=16;
				while(!elems[i].contains("DNS"))
				{
					hset.add(elems[i]);
					i+=1;
				}
			}
			en_index++;
		}
		br.close();
	}
}
